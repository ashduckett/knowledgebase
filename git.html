<!DOCTYPE html>
<html>
	<head>
		<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
	
		<style>
	
		</style>

	</head>
	<body>
		<h1>Automatically Comparing Files</h1>
		<h2>Windows</h2>
		<p>
			You have a tool in the command prompt called <code>FC</code>. This stands for file compare.
		</p>
		<p>
			<code>FC favourite-app-old.html favourite-app-new.html</code>
		</p>
		<img src="fc_example.png">

		<h2>Mac or Linux</h2>
		<p>
			In this case, you have a tool called <code>diff</code>.
		</p>
		<p>
			<code>$ diff -u favourite-app-old.html favourite-app-new.html</code>
		</p>
		<p>
			<code>-u</code> gives you a unified diff format and should make things easier to read.
		</p>
		<img src="diff_example.png">

		<p>
		Lines with no plus or minus sign next to them have not changed, so they are in the old and new versions of the code.
		</p>
		<p>
		Lines with a minus sign were removed. This will mean they were in the old version, but not the new version of the file.
		</p>
		<p>
		Lines with a plus sign were added. So they were not in the old version of the file, but they are in the new one.
		</p>

<table style="width:100%">
  <tr>
    <th>Linux Command</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>mkdir dirname</td>
    <td>Create a new directory with the name dirname</td>
  </tr>
  <tr>
    <td>pwd</td>
    <td>Print the currend directory you're in</td>
  </tr>
    <tr>
    <td>ls</td>
    <td>List the files in the current directory</td>
  </tr>
</table>

<table style="width:100%">
  <tr>
    <th>Git Command</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td>git diff idA idB</td>
    <td>Compare idA and idB where idA and idB are commits, starting with the oldest.</td>
  </tr>
    <tr>
    <td>git log</td>
    <td>TODO</td>
  </tr>
      <tr>
    <td>git log --stat</td>
    <td>Gives some statistics about which files have changed in each commit. You can now see which files are affected by a commit.</td>
  </tr>
  <tr>
  	<td>git --version</td>
    <td>Outputs the version of git running.</td>
  </tr>
    <tr>
  	<td>git status</td>
    <td>This will show the files that have changed since the last commit.</td>
  </tr>
</table>


	<h1>Viewing a Commit History</h1>		
	<p>You can view the commit history of a repository using the following command:</p>
	<p>
	<code>$ git log</code>
	</p>
	<p>
	You will see every commit that's ever been made, starting with the most recent. You can compare one commit with another using git diff checksumA checksumB.
	</p>
	<h1>Got Commits Across Multiple Files</h1>
	<p>
	When you work on a project, you'll usually have multiple files that you want to track together. When you save a version of your files, in other words make a commit, you're saving a version of every file in your repository.
	</p>

	<h1>Cloning a Repo</h1>
	<p>
	This can be done easily using git clone url. It will download the repository and its entire history.
	</p>

	<h1>Checking Out Old Versions of Code</h1>
	<p>
		In git, checking out a commit means resetting all of your files to how they were at the time that commit was made.
	</p>
	<p>
	When you do this you will get a warning that says "You are in 'detached HEAD' state." This is nothing to worry about. Head is what git calls the commit you're currently working on and you've detached it here by checkint out an older commit.
	</p>
	<p>
	If you do a git log with an older commit checked out, you will only get the commits up to the point of your current commit.
	</p>
	<p>
	You can still get back to the most recent commit using git checkout checksum, but what if you don't knot he checksum?
	</p>
	<h1>Configuring git</h1>
	<h2>Background and Text Colour</h2>
	<p>
		This is easily set using the menu found in the top left hand corner.
	</p>

	<h2>Enabling Tab Completion and Prompt Features</h2>
	<p>
		For this you'll need a couple of files. One is git-completion.bash, which will sort out auto-completion. Put this file in your home directory and make sure it doesn't have a .txt extension. 
	</p>
	<p>
		The second file is git-prompt.sh. Do the same thing with this file and put it in your home directory.
	</p>
	<p>
		The final file should be named <a href="#">.bash_profile</a>. You'll need to open this with a text editor and select all files when you save this or it won't let you save it to the home directory.
	</p>
	<h2>Configuring git with Sublime</h2>
	<p>
	$ git config --global core.editor "'C:/Program\ Files/Sublime\ Text\ 3/subl.exe' -n -w"
	</p>
	<p>
	Note that the n means open a new window for sublime and the -w means wait for sublime to close and save before letting git move on.
	</p>

	<h2>Launching your text editor</h2>
	<p>
		You should already be able to launch your editor by typeing the full path to it:
	</p>
	<p>
		$ C:/Program\ Files/Sublime\ Text\ 3/subl.exe
	</p>
	<p>
	Add this to your .bash_profile file: alias subl="C:/Program\ Files/Sublime\ Text\ 3/subl.exe"
	</p>
	<p>
		Finally, the following should come in handy later.
	</p>
	<p>
		git config --global push.default upstream
	</p>
	<p>
		git config --global merge.conflictstyle diff3

	</p>
	<p>
		Maybe add mac instructions here
	</p>
	<h1>Creating and Modifying a Repository</h1>
	<h2>What makes a repository a repository?</h2>
	<p>A .git directory</p>
	<h2>Initialising a Repository</h2>
	<code>git init</code>
	<p>
		There will be no commits in a repository you've just made. If you run git status on a directory with a text file on it where all you've done is run git init, you'll be told you have an untracked file.
	</p>
	<h2>Staging Area</h2>
	<p>
	We know how to initialise an empty repository. Now we'll talk about adding changes to it. Imagine there are three files in your working directory. You also have an empty git repository.
	</p>
	<p>
	You can't just run git commit to create a snapshot of all your files. Remember, keeping commits small is good, with one commit per logical change. Git allows you to do this by allowing you to specify exactly what changes should be committed.
	</p>
	<p>
	To help with this git provides a staging area. You can add files one at a time to a staging area. When you commit, having staged your changes, git will bundle the entire contents of the staging area into a single commit and add it to the repository.
	</p>
	<p>
	So you might use git status to remember what you've added to the staging area so far. Imagine that you have three untracked files only.
	</p>
	<p>
	You stage two of them. Then you run git status and these files now show up as new files under changes to be committed. That means that the files have been added to the staging area.
	</p>
	<p>
	To stage a file you use git add. If you want to unstage a file, you can remove it with reset file_name. This will remove the file from the staging area.
	</p>

	<h2>git diff without arguments</h2>
	<p>
	Doing this will give you a diff between what's been staged and your working directory. This tells you what work you've done since your last added something to the staging area. Remember that you would normally say diff oldThing newThing. In this case the old thing it the staging area and the new thing is your working directory.
	</p>
	<p>
	You might also want to view the difference between the staging area and the most recent commit in the repository. This will tell you if the files you've added are really the changes you want to make to the repository. You can do this with git diff --staged. This command gives you all of the changes that are currently going to be in your next commit.
	</p>
	<p>
		If you need to reset both the staging area (back to the state of the repository) and the working directory back to the state of the repository, then git reset --hard will do this.
	</p>

	<h1>Branches</h1>
	<p>
	As I understand them. As you commit to master, the default branch, you're moving the branch head forward. You can checkout commits and you can checkout branches. When you checkout a branch, you'll get the working directory setup to use the state of files as defined by the latest commit on the current branch. When you make a commit having checked out a branch, the label, or branch, will refer to the new commit.
	</p>
	<p>
	When you get a message telling you that you're in a detached head state, it's telling you that you're on an unlabled commit. For you to be on a branch and not in a detached head state, you'd need to be on the tip of the branch. I believe that this is significant because as you go through a branch history, you'll go through from the tip of the branch, what the branch name refers to, all the way back to the initial commit. This won't include any commits you make whilst in a detached head state since a commit can only have one parent and any commit you made in the detached head state won't be one of them.
	</p>
	<p>
		git branch will show you all of the branches in your repository.
	</p>
	<p>
		git branch nameHere will create a new branch with the name nameHere. If you were to run git branch without any arguments again, you'll see your new branch. You'll see a star next to the currently checked out branch. This is the one that will update if you make a change.
	</p>
	<p>
	If you do git checkout branchName, you'll checkout the branch. If you then do git branch again, you'll see that you've checked out that new branch.
	</p>
	<p>
	Immediately after creating a branch, it will have the same code as the branch on which you created it initially.
	</p>
	<h1>Merging</h1>
	<p>
		Imagine that you want to merge the following and that each letter is a line of code. Two people start with the same version of a file. Each person makes some changes. They might add some lines, or remove some lines. Here is Jake's version at the end of the day:
	</p>
	<ul>
		<li>B</li>
		<li>D</li>
		<li>E</li>
	</ul>
	<p>Here's Rachel's version at the end of the day:</p>
	<ul>
		<li>A</li>
		<li>B</li>
		<li>C</li>
		<li>D</li>
	</ul>
	<p>Looking at the above, how would you merge the two versions of the file together?</p>
	<p>One way to think about it is:</p>
	<ul>
		<li>B and D ara in both versions so it should be in the final file</li>
		<li>A is in Rachel's version, but not Jake's. This means either Rachel added it to the original, or Jake removed it. We don't know which so we can't say whether or not it should be in the final file given just these two files.</li>
		<li>
			C is in Rachel's file but not Jake's. Once again, we don't know if Rachel added it or Jake removed it so we can't say whether or not it should be in the final file.
		</li>
		<li>
			E is in Jake's file but not Rachel's. So Jake may have added it, or Rachel may have removed it. We don't know.
		</li>
	</ul>

	<p>
	Notice that we ask if someone added it or removed it. If someone actively removed a line that was there originally, then it should be removed. If somebody added a line that wasn't there originally, then it should be added.
	</p>
	<p>
	To be able to work out what should be in the merged file, we need to know what the file originally looked like. It's the same when merging in GIT. GIT will use the two commits and the original commit that these branches came from originally to work out what a merged version should look like. 
	</p>
	<h1>Using GitHub</h1>
	<p>
		Your first step would be to create an empty repository on GitHub.
	</p>
	<h2>Adding a Remote</h2>
	<p>
		You can view all of the current remotes in your repository with the command
	</p>
	<p><code>$ git remote</code></p>
	<p>
		You can add your remote with the following command
	</p>
	<p>
	git remote add origin githuburl
	</p>
	<p>
	Note that you're using convention here by naming the remote origin.
	</p>
	<p>If you do</p>
	<p>
		git remote -v
	</p>
	<p>You'll get more information. It will tell you the about the remote you have, namely the url you would fetch data from, and the url you'd push data to.</p>

	<p>Now if you need to push your changes, you can do this with the following command</p>
	<p>
	git push origin master
	</p>
	<p>
	The first argument is the name of the remote you want to send changes to, and also the name of the branch you'd like to push.
	</p>
	
	<h2>Pulling Changes</h2>
	<p>
	If somebody makes changes to the branch that you've got in GitHub, then you will become out of sync with whats on GitHub in your local repository. To fix this, you'll need to pull.
	</p>
	<p>
	<code>
	$ git pull origin master
	</code>
	</p>

	<h2>Forking a Repository</h2>
	<p>
		Forking allows you to make a copy of somebody else's repository directly on the GitHub servers. You could then pull down the code onto your own machine. This is a GitHub concept, not a Git concept, but it can be useful. To do it, you just need to be logged in to GitHub, hit the fork button on somebody else's repository and you'll have a copy that you can do what you like with.
	</p>
	<p>
	It's worth noting that when you clone a repository, git will automatically set up a remote pointing to the repository you cloned from. Check it with the git remote -v command.
	</p>
	</body>



</html>


We ran git init on our directory with our first reflections file in it.
We ran git status and were told that we had untracked files.
We created the second reflections file.
Running git status at this point tells us that we have two untracked files.
We add one to the staging area and commit it with a commit message.
We add another to the staging area and commit it with a commit message.
We make a change to the second file.
We add with git add.
We commit.

Basically at this point everything is committed.